**반정규화의 정의**



![img](https://t1.daumcdn.net/cfile/tistory/241E713F57A319EF2A)



**반정규화(=역정규화, De-Normalization)는 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델리의 기법**을 의미한다. 즉, 데이터를 중복하여 성능을 향상시키는 기법이며, 더 넓은 의미의 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 포함하게 된다. 



**데이터 무결성이 깨질 수 있는 위험성이 있는 반정규화를 적용하는 이유는 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.**





정규화는 입력 / 수정 / 삭제에 대한 성능을 향상시킬 뿐만 아니라 조회에 대해서도 성능을 향상시키는 역할을 한다. 그러나 정규화만을 수행하게 되면 엔티티 개수가 증가하고 관계가 많아져 일부 여러 개의 조인이 걸려야만 데이터를 가져오는 경우가 있다. 이러한 경우 반정규화를 고려하게 되는 것이다. 또한 정규화의 함수적 종속관계는 위반하지 않지만 데이터의 중복성을 증가시켜야만 데이터 조회의 성능을 향상시키는 경우가 있다. 이러한 경우에 반정규화를 수행하여 데이터에 접근하는데 있어서 성능을 높일 수 있도록 한다.



그리고 반정규화는 **프로젝트 설계단계에서 적용**하게 된다.





반정규화를 수행하지 않는 경우

\- 성능이 저하된 데이터 베이스가 생성 될 수 있음

\- 구축단계나 시험단계에서 반정규화를 적용할 때 수정에 따른 노력비용이 많이 듦





**나. 반정규화의 적용방법**



보통 프로젝트에서는 칼럼 중복을 통해서만 반정규화를 수행하게 된다. 칼럼의 반 정규화가 많이 일어나게 되는 까닭은 개발을 하다가 SQL 문장 작성이 복잡해지고 그에 따라 SQL단위 성능 저하가 예상이 되어 다른 테이블에서 조인하여 가져와야 할 칼럼을 기준이 되는 테이블에 중복하여 SQL 문장을 단순하게 처리하도록 하기 위해 요청하는 경우가 많다. 



이렇듯 **무분별하게 칼럼의 반정규화를 많이 하게되면 데이터에 대한 무결성을 깨뜨리는 결정적인 역할을 하게 된다. 반정규화를 적용할 때는 기본적으로 데이터 무결성을 존중하여 보장 할 수 있는 방법을 고려한 이후에 적용**해야한다. 





Trade-Off 관계처럼 정규화만을 강조하게되면 성능의 이슈가 발생될 수 있고, 반정규화를 과도하게 적용하다 보면 데이터 무결성이 깨질 수 있는 위험이 증가하게 되는 것이다. 





![img](https://t1.daumcdn.net/cfile/tistory/271FDB3F57A319F02A)





**반정규화의 절차**



**1. 반정규화의 대상을 조사**



다음과 같은 상황에 반정규화를 수행한다.



\- 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우

\- 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우, 처리 범위를 줄이지 않으면 성능을 보장 할 수 없을 경우 

\- 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별되의 통계테이블을 생성

\- 테이블에 지나친 조인이 걸려있을 때 





**2. 반정규화의 대상에 대해 다른 방법으로 처리할 수 있는지 검토**



가급적 데이터를 중복하여 데이터 무결성을 깨뜨릴 위험을 제어하기 위해 다음과 같이 다른 방법을 모색하도록 한다.



\- 지나치게 많은 조인이 걸려있어 데이터를 조회하는 작업이 기술적으로 어려운 경우 뷰(VIEW)를 생성하여 개발자별로 SQL문장을 만드는 방법에 따라 성능저하가 나타날 수 있는 위험을 예방한다.



\- 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다. 이 때 데이터를 조회가 대부분 이루어지고 인덱스를 통해 성능향상이 불가능할 경우 클러스터링을 고려해 볼 수 있다. 또한 인덱스를 통해 성능향상이 불가능하다면 클러스터링을 고려할 만하다.



\- 대량의 데이터는 Primary Key 성격에 따라 부분적인 테이블로 분리할 수 있다. 즉 파티셔닝 기법(Partitioning)이 적용되어 성능저하를 방지할 수 있다. 인위적인 테이블을 통합 / 분리하지 않고 물리적인 저장기법에 따라 성능을 향상 시킬 수 있다. 따라서 특정 기준에 의해 물리적인 저장공간이 구분될 수 있고 트랜잭션이 들어올 때 일정한 기준에 의해 들어온다면 파티셔닝 테이블을 적용하여 조회의 성능을 향상시키도록 한다.



\- 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다. 





**3. 반정규화를 적용**



테이블 반정규화 / 칼럼 반정규화 / 관계 반정규화 이 세가지 기법 중 선택하여 반정규화를 적용하도록 한다. 













**2. 반정규화의 기법
**





**가. 테이블 반정규화**



![img](https://t1.daumcdn.net/cfile/tistory/2332B43F57A319F11C)







**나. 칼럼 반정규화**



![img](https://t1.daumcdn.net/cfile/tistory/250DD63F57A319F137)







**다. 관계 반정규화**



![img](https://t1.daumcdn.net/cfile/tistory/2432803F57A319F21C)

























**3. 정규화가 잘 정의된 데이터 모델에서 성능이 저하된 경우**





서버 A에 부서와 접수 테이블이 있고 서버 B에 연계라는 테이블이 있는데 서버 B에서 데이터를 조회할 때 빈번하게 조회되는 부서번호가 서버A에 존재하기 때문에 연계, 접수, 부서 테이블이 모두 조인에 걸리게 된다. 게다가 분산데이터베이스 환경이기 때문에 다른 서버간에도 조인이 걸리게 되어 성능이 저하되는 경우이다.





![img](https://t1.daumcdn.net/cfile/tistory/2558933F57A319F301)



위 그림은 정규화된 상태이다. 이 상태에서 서버B의 연계 테이블에서 부서명에 따른 연계상태코드를 가져오는 SQL 구문은 다음과 같이 작성될 수 있다.



SELECT C.부서명, A.연계상태코드

FROM 연계 A, 접수 B, 부서 C

WHERE A.부서코드 = B.부서코드

AND A.접수번호 = B.접수번호

AND B.부서코드 = C.부서코드

AND A.연계일자 BETWEEN '20040801' AND '20040901'





![img](https://t1.daumcdn.net/cfile/tistory/2233CD3F57A319F41B)



위 그림은 다른 서버간 반정규화된 사례이다. 이 모델에 대한 SQL구문은 다음고 ㅏ같다.



SELECT 부서명, 연계상태코드

FROM 연계

WHERE 연계일자 BETWEEN '20040801' AND '20040901'







이처럼 정규화가 잘 된 데이터 모델에서 성능이 저하되는경우 반정규화를 수행하여 성능을 좋게 할 수 있다. 분산되어있는 서버간에도 DB LINK 조인이 발생하지 않아 성능이 개선되었다. 



**반정규화를 적용할 때 데이터를 입력, 수정, 삭제 할 때는 성능이 떨어지는 점을 기억해야하고, 데이터의 무결성 유지에 주의를 기울여야한다.**





출처: https://eehoeskrap.tistory.com/55 